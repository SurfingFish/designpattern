##  计算机硬件的基本构成

>CPU、主板、内存、电源、输入设备、输出设备、显卡

>1、CPU(核心)  计算机中所有计算的部分都在这里进行

>2、内存  所有的程序都要加载到内存中，程序只有加载到内存中才能运行，存放在内存里的程序和数据需要被CPU读取，CPU计算完之后将数据写会到内存。

>3、主板  CPU和内存都插在主板上，主板的芯片组和总线解决了CPU和内存之间通信的问题。总线是实际数据传输的高速公路。

>4、电源  给计算机供电

>5、输入设备(非必须)  输入文本等  都插在主板上、通过南桥(SouthBridge)芯片组，来控制CPU之间的通信。

>6、输出设备(非必须)  显示器显示计算机输出的各种图形文字等

>7、显卡(非必须)  计算机本身内置显卡，如需玩游戏或者进行与图形渲染相关的操作，应该买一张独立显卡。  显卡中包含了CPU 和GPU(图形处理器)



## 冯.诺依曼体系结构

  * 冯.诺依曼体系结构的组成部分：
  * 这一部分可以去看原版冯.诺依曼的原版论文
   > 1、处理器单元(算数逻辑单元、处理器寄存器) 用于完成数据的处理操作 组成CPU
   > 2、内存  存储数据(Data)和指令
   > 3、外部存储 现在是硬盘
   > 4、输出和输入设备

任何一台计算机的任何一个部件都可以归到`运算器`、`控制器`、`存储器`、`输入设备`、`输出设备`中，而所有的现代计算机也都是基于这个基础架构来设计开发的。



## 通过CPU主频，来了解"性能"究竟是什么？

>学习计算机组成原理、和研究计算机组成原理、就是在理解计算机如何工作的，以及为什么要这么运作。"为什么"要解决的事情，就是提升"性能"。



性能的指标：

  * 响应时间(Response time)或者叫执行时间(Execution time)
  * 吞吐率(Throughput)或者带宽(Bandwidth)



如何理解`响应时间`：  可以理解为让计算机跑得更快，比如说浏览器中输入一个网站的地址，然后回车，浏览器中显示页面的速度越快，说明响应时间就越快，比如说更快执行完一个任务。

如何理解`吞吐量(Throughput)`或者`带宽(Bandwidth)`？  可以理解为让计算机一次搬运的东西更多，比如说服务器使用的网络带宽，手机网络带宽，在单位时间内能够上传或下载的数据量。

**结论是：**响应时间指的是，我们执行一个程序，到底要花多少时间。花的时间越少，性能越好。 吞吐率是指在一定的时间范围内，到底能处理多少"事情"，这里的事情就是指`处理的数据`或者`执行的程序指令`。

**如何加大吞吐率？**  

* 1、服务器多加几个核，多个核同时处理数据，单位时间内就可以处理更多数据   

* 2、多加机器、多加硬件

**如何提升响应时间？**

* CPU的性能已经在10年前进入缓慢发展阶段了，**短时间内快速提高性能是不现实的**。
* 单个CPU的主频是有上限的，在CPU中多加几个核，提高主频上限。但是这样会导致程序在内核之间的切换，总的来说现代的计算机多个核还是要比单核来得快一点。

一般把性能定义为响应时间的倒数：

```
   性能= 1/响应时间
```

响应时间越短，性能的数值越大。



**如何评估程序的响应时间？**

> 首先明确一个概念： 一个程序对应多条语句，一条编程语句可能对应多条CPU指令，一个CPU指令可能需要多个CPU周期。
> CPU时间不一定能准确衡量一个程序的性能。即使在同一台计算机上，CPU可能满载运行也可能降频运行，降频运行的时候自然话花的时间更长。

1、程序的运行时间  = CPU执行程序的响应时间，由于计算机**同时运行多个程序**，CPU实际上是不停地在各个程序之间进行`切换`。 在CPU执行当前程序期间，`有可能CPU切换去执行其他程序了`。而且，有些程序运行时需要从外部读取数据到内存中才能运行，所以想要评估一个程序真正的响应时间需要**剔除掉** `CPU切换到其他地方执行的时间`、`程序读取数据到内存的时间`。

**结果：**CPU对程序的响应时间   = 程序的CPU执行时间

=程序执行总时间 - (CPU切换到其他地方执行的时间 + 程序读取数据到内存的时间) 

= CPU时钟周期数×时钟周期时间

=指令数×CPI×Clock Cycle Time

**名词解释：**

* **CPU时钟周期数:**  每一个程序都是由**多条编程语句**来构成的，一条编程语句对应**多条CPU指令**，在CPU中不同的CPU指令执行所需的**时钟周期数**是不同的

* **时钟周期时间：** 举例来说：一个Intel-i7-7700HQ 2.8GHz,这里的2.8GHz就是电脑的主频(Frequency/Clock Rate)。 这个2.8GHz可以**粗浅**的认为是，CPU在一秒钟内，可以执行的简单指令数为2.8G条。 G表示10亿次。也就表示一秒钟内晶体振荡器震动了2.8亿次。

  所以：时钟周期时间=CPU执行一条简单指令的时间= 1/2.8G,CPU主频越高越好，如果要降低时钟周期时间，就得换一块性能更好的CPU。
  
* **CPI** 每条指令的平均时钟周期数

* **指令数 **每个程序都是由多条编程语句构成，每一条编程语句对应多个CPU指令

* **CPU时钟周期** 在CPU内部，有一个晶体振荡器(Oscillator Crystal)，简称晶振。我们把晶振当成CPU内部的电子表来使用。`晶振带来的每一次"滴答"，就是时钟周期时间`。 为了理解可以简单认为就是晶振在触发一条一条电路变化指令，就好像你拨动算盘的节奏一样，拨动得越快，珠算就越快。结果就是一条简单的指令需要的时间和一个时钟周期一样。(粗略地可以这样理解)



查看真正的CPU运行时间：
```shell
 time seq 1000000 | wc -l   
```
real 0m 0.000003s

user 0m 0.000003s

sys   0m 0.000003s 

如果出现了 real 和user的时间相同，这个可能是并行的原因，虽然seq和wc两个命令都是单线程运行的，但是这两个命令在多核CPU运行的情况下，会被分配到两个不同的CPU,玉石user和sys的时间都是两个CPU上运行的时间之和，就有可能超过real的时间。

**CPU性能的最终总结：**

>我们可以想象自己成一个CPU，坐在电脑前写程序。计算机主频就好像打字的速度，打字越快自然就可以多敲一点程序。CPI相当于你在写程序的时候，熟悉各种快捷键，越是打同样的内容，需要敲击键盘的次数越少。 指令数相当于程序设计得够合理，同样的程序要写的代码行数就越少。如果三者都实现，你自然就很快可以写出一个优秀的程序。你的`性能`从外面来看就是好的。





## 应该从哪方面提升性能？

>    程序的CPU执行时间 = 指令数×CPI×Clock Cycle Time  
>计算机性能可以从指令数、CPI以及CPU主频入手。CPI、指令数都是不容易改变的。所以提高主频是提升计算机性能一开始最好的方法。

计算机主频的历史：
1、1978  Intel  8086   主频  5MHz
2、1980 Intel 80386  主频  40MHz
3、1989 Intel 486       主频 100MHz
4、2000 Intel  奔腾     主频 1.4GHz
5、CPU主频极限  10GHz

**为什么奔腾4架构的主频没有超过3.8GHz**？

* 因为功耗问题  一个3.8GHz的奔腾4处理器，满载是130瓦。机场允许带上飞机的充电宝容量最高为100瓦，如果将CPU安装在手机上，CPU满载45分钟，充电宝就没电了。IphoneX使用AMD架构的CPU，功率只有45瓦。

**CPU的实质：**
* 超大规模集成电路(Very-Large-Scale Integration) 实际上是由一个个晶体管组成的。
* CPU的计算：  让晶体管中的”开关“不断地去“打开”和“关闭”，完成各种运算与功能。

**如何提高主频：**

* 增加晶体管密度 
* 让晶体管“打开”和”关闭“更快一些。也就是提高主频
* 提高主频的两种方法都会增加功耗，带来耗电和散热的问题。

**为何不提高CPU面积呢？ **

* 晶体管之间的距离变大，电信号传输时间就会变慢，速度就慢了。

因为大量的晶体管和晶体管的快速“开关”会导致释放大量的热量。不管是在CPU上抹硅脂还是装风扇抑或是上水冷，散热都是有极限的。超出了这个极限CPU就不能工作了。所以在单位面积上能放下的晶体管数量和晶体管的”开关“频率是有限的。

**CPU的功率公式**

> 功耗 = 1/2 ×负载电容×电压的平方×晶体管数量

为了提高性能，要增加晶体管数量，和增加晶体管“开关”的速度。 
* 将晶体管提升制程，将晶体管变得更小一点。 28nm变为7nm。
* 提供主频，使得晶体管”开关“速度变得更快。
* 上面两个方法引发了功耗问题和散热的问题。为了解决这两个问题，可以降低电压，功耗和电压的平方是成反比的。以为着电压下降到原来的1/5，整个功耗会变为1/25.
* 除了上面的方法提升效率达到了提升主频的极限之外，还可以通过提高”吞吐量“(通过增加CPU核数、通过并行提高性能)来提升CPU的效率。并行优化的理解：`详细请看计算机组成原理pdf第四章，穿越功耗墙。`

使用并行优化需要满足一下条件：
* 需要进行的计算，本身可以分解为几个可以并行的任务。
* 需要能够分解好问题，并确保几个人的结果能汇总到一起。
* 在”汇总阶段“，是没有办法并行进行的。还得顺序执行。


在进行性能优化中，常常用到一个经验定律，**阿姆达尔定律**。程序优化之后，处理器并行运算之后效率的提升情况为：
> 优化后的执行时间 = 受优化影响的执行时间/加速倍数 + 不受影响的执行时间
汇总时间是不受影响的执行时间

**总结：**
无论是简单地提高主频，还是增加更多的CPU核心数量，通过并行来提高性能，都会遇到相应的瓶颈。仅仅通过"堆硬件"的方式，在今天已经不能很好地满足对于程序性能的要求了。


除了“摩尔定律”和“并行计算”之外，在整个计算机组成层面上，还有以下几个原则性的性能提高方法。

* 1、**加速大概率事件。**可对应`缓存静态文件`、`redis缓存`、`加速编译热点代码`、`CDN缓存`等，硬件方面的例子是使用GPU代替CPU，提升了深度学习的模型训练过程。

* 2、**通过流水线提高性能。** 将装配iPhone的任务拆分为一个个细分的任务，每个人处理一道工序，最大化提个整个工厂的生产效率。类似的，CPU其实就是一个“运算工厂”。过长的流水线会带来新的功耗和效率上的负面影响.

* 3、通过预测提高性能。





