​	

##                         按照领域驱动模型来解决问题的真实案例

参考博客：<https://segmentfault.com/p/1210000012568717/read>

##    问题

###         1、过度耦合

​		业务初期，我们的功能大都非常简单，普通的CURD就能满足，此时系统是清晰的。随着迭代的不断演化，逻辑变得越来越复杂，我们的系统也变得越来越冗杂。 模块彼此互相关联，谁都很难说得清楚具体功能亿图是什么。修改一个功能时，往往光回溯该功能需要的修改点就需要很长时间，更别提修改带来的不可预知的影响面了。

 

下图是一个常见的系统耦合病例。

![img](https://segmentfault.com/img/remote/1460000012568724?w=706&h=316)





订单服务接口中提供了查询、创建订单相关的接口，也提供了评价、支付、保险的接口。同时我们的表也是一个订单大表，包含了非常多的字段。在我们维护代码的时候，牵一发动全身，很可能这是想修改一下评价相关的功能，却影响到了创建订单的和新路径。虽然我们可以通过**测试**保证功能完备性，但我们在订单领域有大量需求同时并行开发时，改动重叠、恶性循环、疲于奔命修改各种问题。



上述的问题，归根结底在于系统架构不清晰，划分出来的模块内聚度低、高耦合。



##### 重构、驱动测试开发、持续集成

有一种解决方案，按照演进式设计的理论，让系统的设计随着系统实现的增长而增长。我们不需要做提前设计，就让系统伴随业务成长而演进。这当然是可行的，敏捷实战中的**重构**、**驱动测试设计**以及**持续集成**可以对付各种混乱问题。**重构--保持行为不变的代码改善清除了不协调的局部设计**，**测试驱动设计确保了对系统的更改不会导致系统丢失或破坏现有功能**，**持续集成则称为团队提供了统一代码库。**

在这三种实践中，重构是客服演进式设计中大杂烩问题的主力，通过在单独的类及方法级别上做一系列小步重构来完成。我们可以很容易从狗出一个独立的类来放某些通用的逻辑，**但是**你会发现你很难给它一个业务上的含义，只能给予一个技术维度描述的含义。**这会导致一些问题！**

新入职的开发人员并不总是知道**对通用逻辑的改动或获取**来自该类。



用DDD则可以很好解决**领域模型**到**设计模型**的同步、演化、最后再将反映了领域的设计模型转为实际的代码。



住：**模型是我们解决实际问题所抽象出来的概念模型，领域模型则表达业务相关的事实；设计模型则描述了所有要构建的系统。**





##   2、贫血和失忆症

##### 	1、 贫血领域对象

##### 	1.1、贫血领域对象(Anemic Domain Object) 是指仅用作数据载体，而没有行为和动作的领域对象。



​	在我们习惯了J2EE的开发模式后，Action/Service/DAO这种分层模式，会很自然地写出过程式代码，而学到的很多关于OO理论的也将毫无用武之地。使用这种开发方式，**对象只是数据的载体、没有行为。**以数据为中心，以数据库ER设计作为驱动。分层架构在这种开发模式下，可以理解为是对数据移动、处理、实现的过程。

​	  

​		

​		下面是一个真实的开发案例：

- 场景需求

  奖池里配置了很多奖项，我们需要按照运营预先配置的概率抽中一个奖项。

  实现非常简单，生成一个随机数，匹配符合该随机数生成概率的奖项即可。

- 贫血模型实现方案

  先设计奖池和奖项的库表配置

  ![img](https://segmentfault.com/img/remote/1460000012568725?w=482&h=148)

- 设计AwardPool和Award两个对象，只有简单的get和set属性和方法

  

```java
class AwardPool{
 	int awardPoolId;
 	List<Award> award;
 	
 	public List<Award> getAwards(){
        return awards;
 	}
 	
    public void setAwards(List<Award> awards) {
        this.awards = awards;
    }
}

class Award {
    int awardId;
    int probability;//概率
    
    get set 
}
```



- Service代码实现

  设计一个LotteyService，其中的drawLottery()方法写服务逻辑

  ```java
  AwardPool awardPool = awardPoolDao.getAwardPool(poolId);//SQL查询，将数据映射到AwardPool对象
  awardPool.getAward(){ //寻找符合award.getProbiliy()概率的award}
  ```

  



- 按照我们通常的思路实现，可以发现：在业务领域里非常重要的抽奖，我的业务都是写在Service层中的，Award充其量只是数据载体，没有任何行为。简单的业务网系统采用这种贫血模型和过程化设计是没有问题的，但是业务逻辑复杂了之后，业务逻辑、状态会散落在大量的方法中，原本的代码意图会渐渐不明确，我们将这种情况称为贫血引起的失忆症。

更好的是采用领域模型的开发方式，将数据和行为封装到一起，并与现实世界中的业务对象相映射。各类具备明确的职责划分，将领域逻辑分散到领域对象中。继续我们上述的抽象例子，使用概率选择对应的奖品就应该放在AwardPool类中。







## 3、如何实践DDD

​	我们将通过上文提到的抽奖平台，来详细介绍我们如何通过DDD来解构一个中型的基于微服务架构的系统，从而做到系统的高内聚，低耦合。



​	首先看下抽奖系统的大致需求：



运营-- 可以配置一个抽奖活动，该活动面向一个特定的用户群体，并针对一个用户群体发放一批不同类型的奖品(优惠券、激活码、实体奖品等)。

